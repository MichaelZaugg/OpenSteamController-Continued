<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Line Status Register. Contains flags for transmit and receive status, including line errors"><title>lpc11xx::uart::lsr - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Italic-81dc35de.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-MediumItalic-ccf7e434.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../../../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../../../static.files/rustdoc-1a91846b.css"><meta name="rustdoc-vars" data-root-path="../../../" data-static-root-path="../../../static.files/" data-current-crate="lpc11xx" data-themes="" data-resource-suffix="" data-rustdoc-version="1.88.0 (6b00bc388 2025-06-23)" data-channel="1.88.0" data-search-js="search-f7877310.js" data-settings-js="settings-5514c975.js" ><script src="../../../static.files/storage-4e99c027.js"></script><script defer src="../sidebar-items.js"></script><script defer src="../../../static.files/main-7ef8a74a.js"></script><noscript><link rel="stylesheet" href="../../../static.files/noscript-893ab5e7.css"></noscript><link rel="alternate icon" type="image/png" href="../../../static.files/favicon-32x32-6580c154.png"><link rel="icon" type="image/svg+xml" href="../../../static.files/favicon-044be391.svg"></head><body class="rustdoc mod"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../../../lpc11xx/index.html">lpc11xx</a><span class="version">0.2.0</span></h2></div><div class="sidebar-elems"><section id="rustdoc-toc"><h2 class="location"><a href="#">Module lsr</a></h2><h3><a href="#enums">Module Items</a></h3><ul class="block"><li><a href="#enums" title="Enums">Enums</a></li><li><a href="#types" title="Type Aliases">Type Aliases</a></li></ul></section><div id="rustdoc-modnav"><h2><a href="../index.html">In lpc11xx::<wbr>uart</a></h2></div></div></nav><div class="sidebar-resizer"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><div class="rustdoc-breadcrumbs"><a href="../../index.html">lpc11xx</a>::<wbr><a href="../index.html">uart</a></div><h1>Module <span>lsr</span><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><a class="src" href="../../../src/lpc11xx/uart/lsr.rs.html#1-356">Source</a> </span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>Line Status Register. Contains flags for transmit and receive status, including line errors</p>
</div></details><h2 id="enums" class="section-header">Enums<a href="#enums" class="anchor">ยง</a></h2><dl class="item-table"><dt><a class="enum" href="enum.BI_A.html" title="enum lpc11xx::uart::lsr::BI_A">BI_A</a></dt><dd>Break Interrupt. When RXD1 is held in the spacing state (all zeros) for one full character transmission (start, data, parity, stop), a break interrupt occurs. Once the break condition has been detected, the receiver goes idle until RXD1 goes to marking state (all ones). A LSR read clears this status bit. The time of break detection is dependent on FCR[0]. Note: The break interrupt is associated with the character at the top of the UART RBR FIFO.</dd><dt><a class="enum" href="enum.FE_A.html" title="enum lpc11xx::uart::lsr::FE_A">FE_A</a></dt><dd>Framing Error. When the stop bit of a received character is a logic 0, a framing error occurs. A LSR read clears LSR[3]. The time of the framing error detection is dependent on FCR0. Upon detection of a framing error, the RX will attempt to re-synchronize to the data and assume that the bad stop bit is actually an early start bit. However, it cannot be assumed that the next received byte will be correct even if there is no Framing Error. Note: A framing error is associated with the character at the top of the UART RBR FIFO.</dd><dt><a class="enum" href="enum.OE_A.html" title="enum lpc11xx::uart::lsr::OE_A">OE_A</a></dt><dd>Overrun Error. The overrun error condition is set as soon as it occurs. A LSR read clears LSR[1]. LSR[1] is set when UART RSR has a new character assembled and the UART RBR FIFO is full. In this case, the UART RBR FIFO will not be overwritten and the character in the UART RSR will be lost.</dd><dt><a class="enum" href="enum.PE_A.html" title="enum lpc11xx::uart::lsr::PE_A">PE_A</a></dt><dd>Parity Error. When the parity bit of a received character is in the wrong state, a parity error occurs. A LSR read clears LSR[2]. Time of parity error detection is dependent on FCR[0]. Note: A parity error is associated with the character at the top of the UART RBR FIFO.</dd><dt><a class="enum" href="enum.RDR_A.html" title="enum lpc11xx::uart::lsr::RDR_A">RDR_A</a></dt><dd>Receiver Data Ready. LSR[0] is set when the RBR holds an unread character and is cleared when the UART RBR FIFO is empty.</dd><dt><a class="enum" href="enum.RXFE_A.html" title="enum lpc11xx::uart::lsr::RXFE_A">RXFE_A</a></dt><dd>Error in RX FIFO. LSR[7] is set when a character with a RX error such as framing error, parity error or break interrupt, is loaded into the RBR. This bit is cleared when the LSR register is read and there are no subsequent errors in the UART FIFO.</dd><dt><a class="enum" href="enum.TEMT_A.html" title="enum lpc11xx::uart::lsr::TEMT_A">TEMT_A</a></dt><dd>Transmitter Empty. TEMT is set when both THR and TSR are empty; TEMT is cleared when either the TSR or the THR contain valid data.</dd><dt><a class="enum" href="enum.THRE_A.html" title="enum lpc11xx::uart::lsr::THRE_A">THRE_A</a></dt><dd>Transmitter Holding Register Empty. THRE is set immediately upon detection of an empty UART THR and is cleared on a THR write.</dd></dl><h2 id="types" class="section-header">Type Aliases<a href="#types" class="anchor">ยง</a></h2><dl class="item-table"><dt><a class="type" href="type.BI_R.html" title="type lpc11xx::uart::lsr::BI_R">BI_R</a></dt><dd>Reader of field <code>BI</code></dd><dt><a class="type" href="type.FE_R.html" title="type lpc11xx::uart::lsr::FE_R">FE_R</a></dt><dd>Reader of field <code>FE</code></dd><dt><a class="type" href="type.OE_R.html" title="type lpc11xx::uart::lsr::OE_R">OE_R</a></dt><dd>Reader of field <code>OE</code></dd><dt><a class="type" href="type.PE_R.html" title="type lpc11xx::uart::lsr::PE_R">PE_R</a></dt><dd>Reader of field <code>PE</code></dd><dt><a class="type" href="type.R.html" title="type lpc11xx::uart::lsr::R">R</a></dt><dd>Reader of register LSR</dd><dt><a class="type" href="type.RDR_R.html" title="type lpc11xx::uart::lsr::RDR_R">RDR_R</a></dt><dd>Reader of field <code>RDR</code></dd><dt><a class="type" href="type.RXFE_R.html" title="type lpc11xx::uart::lsr::RXFE_R">RXFE_R</a></dt><dd>Reader of field <code>RXFE</code></dd><dt><a class="type" href="type.TEMT_R.html" title="type lpc11xx::uart::lsr::TEMT_R">TEMT_R</a></dt><dd>Reader of field <code>TEMT</code></dd><dt><a class="type" href="type.THRE_R.html" title="type lpc11xx::uart::lsr::THRE_R">THRE_R</a></dt><dd>Reader of field <code>THRE</code></dd></dl></section></div></main></body></html>