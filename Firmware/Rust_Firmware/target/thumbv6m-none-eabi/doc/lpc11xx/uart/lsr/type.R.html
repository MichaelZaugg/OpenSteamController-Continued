<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Reader of register LSR"><title>R in lpc11xx::uart::lsr - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Italic-81dc35de.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-MediumItalic-ccf7e434.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../../../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../../../static.files/rustdoc-1a91846b.css"><meta name="rustdoc-vars" data-root-path="../../../" data-static-root-path="../../../static.files/" data-current-crate="lpc11xx" data-themes="" data-resource-suffix="" data-rustdoc-version="1.88.0 (6b00bc388 2025-06-23)" data-channel="1.88.0" data-search-js="search-f7877310.js" data-settings-js="settings-5514c975.js" ><script src="../../../static.files/storage-4e99c027.js"></script><script defer src="sidebar-items.js"></script><script defer src="../../../static.files/main-7ef8a74a.js"></script><noscript><link rel="stylesheet" href="../../../static.files/noscript-893ab5e7.css"></noscript><link rel="alternate icon" type="image/png" href="../../../static.files/favicon-32x32-6580c154.png"><link rel="icon" type="image/svg+xml" href="../../../static.files/favicon-044be391.svg"></head><body class="rustdoc type"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../../../lpc11xx/index.html">lpc11xx</a><span class="version">0.2.0</span></h2></div><div class="sidebar-elems"><section id="rustdoc-toc"><h2 class="location"><a href="#">R</a></h2><h3><a href="#aliased-type">Aliased Type</a></h3><h3><a href="#implementations">Methods</a></h3><ul class="block method"><li><a href="#method.bi" title="bi">bi</a></li><li><a href="#method.fe" title="fe">fe</a></li><li><a href="#method.oe" title="oe">oe</a></li><li><a href="#method.pe" title="pe">pe</a></li><li><a href="#method.rdr" title="rdr">rdr</a></li><li><a href="#method.rxfe" title="rxfe">rxfe</a></li><li><a href="#method.temt" title="temt">temt</a></li><li><a href="#method.thre" title="thre">thre</a></li></ul></section><div id="rustdoc-modnav"><h2><a href="index.html">In lpc11xx::<wbr>uart::<wbr>lsr</a></h2></div></div></nav><div class="sidebar-resizer"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><div class="rustdoc-breadcrumbs"><a href="../../index.html">lpc11xx</a>::<wbr><a href="../index.html">uart</a>::<wbr><a href="index.html">lsr</a></div><h1>Type Alias <span class="type">R</span><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><a class="src" href="../../../src/lpc11xx/uart/lsr.rs.html#2">Source</a> </span></div><pre class="rust item-decl"><code>pub type R = <a class="struct" href="../../generic/struct.R.html" title="struct lpc11xx::generic::R">R</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.88.0/core/primitive.u32.html">u32</a>, <a class="type" href="../type.LSR.html" title="type lpc11xx::uart::LSR">LSR</a>&gt;;</code></pre><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>Reader of register LSR</p>
</div></details><h2 id="aliased-type" class="section-header">Aliased Type<a href="#aliased-type" class="anchor">ยง</a></h2><pre class="rust item-decl"><code>struct R { <span class="comment">/* private fields */</span> }</code></pre><h2 id="implementations" class="section-header">Implementations<a href="#implementations" class="anchor">ยง</a></h2><div id="implementations-list"><details class="toggle implementors-toggle" open><summary><section id="impl-R%3Cu32,+Reg%3Cu32,+_LSR%3E%3E" class="impl"><a class="src rightside" href="../../../src/lpc11xx/uart/lsr.rs.html#315-356">Source</a><a href="#impl-R%3Cu32,+Reg%3Cu32,+_LSR%3E%3E" class="anchor">ยง</a><h3 class="code-header">impl <a class="type" href="type.R.html" title="type lpc11xx::uart::lsr::R">R</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.rdr" class="method"><a class="src rightside" href="../../../src/lpc11xx/uart/lsr.rs.html#318-320">Source</a><h4 class="code-header">pub fn <a href="#method.rdr" class="fn">rdr</a>(&amp;self) -&gt; <a class="type" href="type.RDR_R.html" title="type lpc11xx::uart::lsr::RDR_R">RDR_R</a></h4></section></summary><div class="docblock"><p>Bit 0 - Receiver Data Ready. LSR[0] is set when the RBR holds an unread character and is cleared when the UART RBR FIFO is empty.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.oe" class="method"><a class="src rightside" href="../../../src/lpc11xx/uart/lsr.rs.html#323-325">Source</a><h4 class="code-header">pub fn <a href="#method.oe" class="fn">oe</a>(&amp;self) -&gt; <a class="type" href="type.OE_R.html" title="type lpc11xx::uart::lsr::OE_R">OE_R</a></h4></section></summary><div class="docblock"><p>Bit 1 - Overrun Error. The overrun error condition is set as soon as it occurs. A LSR read clears LSR[1]. LSR[1] is set when UART RSR has a new character assembled and the UART RBR FIFO is full. In this case, the UART RBR FIFO will not be overwritten and the character in the UART RSR will be lost.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.pe" class="method"><a class="src rightside" href="../../../src/lpc11xx/uart/lsr.rs.html#328-330">Source</a><h4 class="code-header">pub fn <a href="#method.pe" class="fn">pe</a>(&amp;self) -&gt; <a class="type" href="type.PE_R.html" title="type lpc11xx::uart::lsr::PE_R">PE_R</a></h4></section></summary><div class="docblock"><p>Bit 2 - Parity Error. When the parity bit of a received character is in the wrong state, a parity error occurs. A LSR read clears LSR[2]. Time of parity error detection is dependent on FCR[0]. Note: A parity error is associated with the character at the top of the UART RBR FIFO.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.fe" class="method"><a class="src rightside" href="../../../src/lpc11xx/uart/lsr.rs.html#333-335">Source</a><h4 class="code-header">pub fn <a href="#method.fe" class="fn">fe</a>(&amp;self) -&gt; <a class="type" href="type.FE_R.html" title="type lpc11xx::uart::lsr::FE_R">FE_R</a></h4></section></summary><div class="docblock"><p>Bit 3 - Framing Error. When the stop bit of a received character is a logic 0, a framing error occurs. A LSR read clears LSR[3]. The time of the framing error detection is dependent on FCR0. Upon detection of a framing error, the RX will attempt to re-synchronize to the data and assume that the bad stop bit is actually an early start bit. However, it cannot be assumed that the next received byte will be correct even if there is no Framing Error. Note: A framing error is associated with the character at the top of the UART RBR FIFO.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.bi" class="method"><a class="src rightside" href="../../../src/lpc11xx/uart/lsr.rs.html#338-340">Source</a><h4 class="code-header">pub fn <a href="#method.bi" class="fn">bi</a>(&amp;self) -&gt; <a class="type" href="type.BI_R.html" title="type lpc11xx::uart::lsr::BI_R">BI_R</a></h4></section></summary><div class="docblock"><p>Bit 4 - Break Interrupt. When RXD1 is held in the spacing state (all zeros) for one full character transmission (start, data, parity, stop), a break interrupt occurs. Once the break condition has been detected, the receiver goes idle until RXD1 goes to marking state (all ones). A LSR read clears this status bit. The time of break detection is dependent on FCR[0]. Note: The break interrupt is associated with the character at the top of the UART RBR FIFO.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.thre" class="method"><a class="src rightside" href="../../../src/lpc11xx/uart/lsr.rs.html#343-345">Source</a><h4 class="code-header">pub fn <a href="#method.thre" class="fn">thre</a>(&amp;self) -&gt; <a class="type" href="type.THRE_R.html" title="type lpc11xx::uart::lsr::THRE_R">THRE_R</a></h4></section></summary><div class="docblock"><p>Bit 5 - Transmitter Holding Register Empty. THRE is set immediately upon detection of an empty UART THR and is cleared on a THR write.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.temt" class="method"><a class="src rightside" href="../../../src/lpc11xx/uart/lsr.rs.html#348-350">Source</a><h4 class="code-header">pub fn <a href="#method.temt" class="fn">temt</a>(&amp;self) -&gt; <a class="type" href="type.TEMT_R.html" title="type lpc11xx::uart::lsr::TEMT_R">TEMT_R</a></h4></section></summary><div class="docblock"><p>Bit 6 - Transmitter Empty. TEMT is set when both THR and TSR are empty; TEMT is cleared when either the TSR or the THR contain valid data.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.rxfe" class="method"><a class="src rightside" href="../../../src/lpc11xx/uart/lsr.rs.html#353-355">Source</a><h4 class="code-header">pub fn <a href="#method.rxfe" class="fn">rxfe</a>(&amp;self) -&gt; <a class="type" href="type.RXFE_R.html" title="type lpc11xx::uart::lsr::RXFE_R">RXFE_R</a></h4></section></summary><div class="docblock"><p>Bit 7 - Error in RX FIFO. LSR[7] is set when a character with a RX error such as framing error, parity error or break interrupt, is loaded into the RBR. This bit is cleared when the LSR register is read and there are no subsequent errors in the UART FIFO.</p>
</div></details></div></details></div><script src="../../../type.impl/lpc11xx/generic/struct.R.js" data-self-path="lpc11xx::uart::lsr::R" async></script></section></div></main></body></html>